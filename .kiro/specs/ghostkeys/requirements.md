# Requirements Document

## Introduction

GhostKeys is a Windows-only System Tray application written in Rust that intercepts keyboard input to simulate ABNT2 (Brazilian) layout behavior on a US-International keyboard. The application uses a state machine to handle dead keys (accents) and provides context-aware remapping based on the active window. The goal is to provide seamless Brazilian Portuguese typing on US keyboards while maintaining low latency and system stability.

## Glossary

- **GhostKeys**: The Windows System Tray application that intercepts and remaps keyboard input
- **Dead Key**: A key that does not generate a character by itself but modifies the character generated by the next key pressed (e.g., `'` or `~`)
- **ABNT2**: The Brazilian keyboard layout standard that includes characters like `ç`, `ã`, `õ`
- **US-International Keyboard**: A keyboard layout commonly used in the United States
- **Keyboard Hook**: A system-level mechanism that intercepts keyboard events before they reach applications
- **State Machine**: A computational model that transitions between states based on input events
- **Passthrough Mode**: A mode where GhostKeys does not modify keyboard input
- **Active Mode**: A mode where GhostKeys intercepts and remaps keyboard input
- **System Tray**: The notification area in the Windows taskbar where background applications display icons
- **Active Window**: The currently focused window receiving user input

## Requirements

### Requirement 1: Dead Key Interception and Character Remapping

**User Story:** As a Brazilian Portuguese user with a US-International keyboard, I want GhostKeys to convert dead key sequences into ABNT2 characters, so that I can type Portuguese characters naturally.

#### Acceptance Criteria

1. WHEN the user types the dead key sequence `'` followed by `c`, THEN GhostKeys SHALL output the character `ç`
2. WHEN the user types the dead key sequence `'` followed by `C`, THEN GhostKeys SHALL output the character `Ç`
3. WHEN the user types the dead key sequence `~` followed by `a`, THEN GhostKeys SHALL output the character `ã`
4. WHEN the user types the dead key sequence `~` followed by `A`, THEN GhostKeys SHALL output the character `Ã`
5. WHEN the user types the dead key sequence `~` followed by `o`, THEN GhostKeys SHALL output the character `õ`
6. WHEN the user types the dead key sequence `~` followed by `O`, THEN GhostKeys SHALL output the character `Õ`
7. WHEN the user types a dead key followed by a non-matching character, THEN GhostKeys SHALL output the dead key character followed by the typed character
8. WHEN the user types a dead key followed by a space, THEN GhostKeys SHALL output only the dead key character

### Requirement 2: State Machine for Dead Key Handling

**User Story:** As a user, I want GhostKeys to track dead key state accurately, so that character sequences are processed correctly without losing keystrokes.

#### Acceptance Criteria

1. WHEN GhostKeys starts, THEN GhostKeys SHALL initialize the state machine in the Idle state
2. WHEN the state machine is in Idle state and the user presses a dead key, THEN GhostKeys SHALL transition to the PendingAccent state and store the dead key
3. WHEN the state machine is in PendingAccent state and the user presses a combinable character, THEN GhostKeys SHALL output the combined character and transition to Idle state
4. WHEN the state machine is in PendingAccent state and the user presses a non-combinable character, THEN GhostKeys SHALL output the stored dead key followed by the pressed character and transition to Idle state
5. WHEN the state machine is in PendingAccent state and a timeout of 500 milliseconds elapses, THEN GhostKeys SHALL output the stored dead key and transition to Idle state

### Requirement 3: Context-Aware Window Detection

**User Story:** As a developer, I want GhostKeys to disable remapping in specific applications like VSCode, so that I can use native keyboard shortcuts without interference.

#### Acceptance Criteria

1. WHEN the active window process name matches "Code.exe" or window title contains "Visual Studio Code", THEN GhostKeys SHALL operate in Passthrough Mode
2. WHEN the active window process name matches "slack.exe" or window title contains "Slack", THEN GhostKeys SHALL operate in Active Mode
3. WHEN the active window does not match any configured rule, THEN GhostKeys SHALL operate in Active Mode by default
4. WHEN the active window changes, THEN GhostKeys SHALL detect the change within 100 milliseconds
5. WHEN GhostKeys cannot determine the active window, THEN GhostKeys SHALL default to Active Mode

### Requirement 4: System Tray Integration

**User Story:** As a user, I want GhostKeys to run in the System Tray with a context menu, so that I can control the application without a visible window.

#### Acceptance Criteria

1. WHEN GhostKeys starts, THEN GhostKeys SHALL display an icon in the Windows System Tray
2. WHEN the user right-clicks the System Tray icon, THEN GhostKeys SHALL display a context menu with options
3. WHEN the user selects "Pause" from the context menu, THEN GhostKeys SHALL enter Passthrough Mode globally and update the menu to show "Resume"
4. WHEN the user selects "Resume" from the context menu, THEN GhostKeys SHALL restore context-aware mode detection and update the menu to show "Pause"
5. WHEN the user selects "Exit" from the context menu, THEN GhostKeys SHALL release the keyboard hook and terminate gracefully

### Requirement 5: Performance and Latency

**User Story:** As a user, I want GhostKeys to process keystrokes with minimal latency, so that my typing experience remains smooth and responsive.

#### Acceptance Criteria

1. WHILE GhostKeys is processing a keystroke, GhostKeys SHALL complete the processing within 10 milliseconds
2. WHILE GhostKeys is running, GhostKeys SHALL consume less than 50 megabytes of memory
3. WHILE GhostKeys is idle, GhostKeys SHALL consume less than 1 percent CPU usage

### Requirement 6: Panic Safety and Hook Release

**User Story:** As a user, I want GhostKeys to release the keyboard hook immediately if it crashes, so that my keyboard remains functional.

#### Acceptance Criteria

1. WHEN GhostKeys encounters an unrecoverable error, THEN GhostKeys SHALL release the keyboard hook before terminating
2. WHEN GhostKeys receives a termination signal, THEN GhostKeys SHALL release the keyboard hook within 100 milliseconds
3. WHEN the keyboard hook thread panics, THEN GhostKeys SHALL catch the panic and release the hook before propagating the error
4. WHEN GhostKeys starts, THEN GhostKeys SHALL register a panic handler that ensures hook release

### Requirement 7: Keyboard Hook Management

**User Story:** As a system administrator, I want GhostKeys to manage the keyboard hook responsibly, so that it does not interfere with other applications or system stability.

#### Acceptance Criteria

1. WHEN GhostKeys starts, THEN GhostKeys SHALL install a low-level keyboard hook using the Windows API
2. WHEN GhostKeys is in Active Mode and intercepts a remappable key sequence, THEN GhostKeys SHALL suppress the original keystroke and inject the replacement character
3. WHEN GhostKeys is in Passthrough Mode, THEN GhostKeys SHALL allow all keystrokes to pass through unmodified
4. WHEN GhostKeys terminates, THEN GhostKeys SHALL uninstall the keyboard hook and release all system resources
